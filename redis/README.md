# Redis

## Внутреннее устройство

### Типы данных

* [Strings](https://redis.io/docs/data-types/strings/)
* [Lists](https://redis.io/docs/data-types/lists/)
* [Sets](https://redis.io/docs/data-types/sets/)
* [Streams](https://redis.io/docs/data-types/streams/)

### Репликация

Каждый ведущий узел Redis имеет идентификатор (Replication ID) и смещение репликации. Смещение увеличивается при
выполнении любого действия, которое происходит в ведущем узле Redis.

Когда подчинённый узел Redis отстаёт лишь на несколько шагов смещения от ведущего узла, он получает оставшиеся
необработанными команды от ведущего узла, эти команды применяются к данным, так происходит до момента синхронизации
узлов. Если два экземпляра не могут договориться об ID репликации, или ведущий узел не имеет сведений о смещении,
подчинённый узел запрашивает полную синхронизацию данных. Сюда входит создание ведущим узлом нового snapshot RDB и
отправка его подчинённому узлу. В процессе передачи этих данных ведущий узел буферизует промежуточные обновления данных,
произошедшие между моментом создания snapshot и текущим моментом. Эти обновления будут отправлены подчинённому узлу
после того, как он синхронизируется со snapshot. После завершения этого процесса репликация может продолжаться в обычном
режиме.

### Sentinel

Redis Sentinel — это сервис, обеспечивающий создание распределённых систем. И, как и в случае со всеми распределёнными
системами, у Sentinel имеются и сильные, и слабые стороны. В основе Sentinel лежит кластер Sentinel-процессов,
работающих совместно. Они координируют состояние системы, реализуя конфигурацию высокой доступности Redis. Sentinel —
это сервис, защищающий хранилище Redis от сбоев. Поэтому логично то, чтобы этот сервис не имел бы единой точки отказа.

Сервис Sentinel решает несколько задач. Во-первых — он обеспечивает работоспособность и доступность текущих ведущих и
подчинённых узлов. Благодаря этому текущий Sentinel-процесс (вместе с другими подобными процессами) может отреагировать
на ситуацию, когда теряется связь с ведущими и/или подчинёнными узлами. Во-вторых — он играет определённую роль в деле
обнаружения сервисов. Похожим образом в других системах работают Zookeeper и Consul. То есть — когда новый клиент
пытается что-то записать в хранилище Redis, Sentinel сообщит клиенту о том, какой экземпляр Redis в этот момент является
ведущим.

Получается, что узлы Sentinel постоянно мониторят доступность экземпляров Redis и отправляют сведения о них клиентам,
что позволяет клиентам предпринимать определённые действия в тех случаях, когда хранилище даёт сбой.

Использование Redis Sentinel для решения вышеописанных задач позволяет обнаруживать сбои Redis. Процедура обнаружения
сбоя включает в себя получение согласия нескольких узлов Sentinel с тем, что текущий ведущий экземпляр Redis недоступен.
Процесс получения такого согласия называют кворумом (quorum). Это позволяет повысить надёжность системы, защититься от
ситуаций, когда один из процессов ведёт себя неправильно и не может подключиться к ведущему узлу Redis.

| Количество серверов | Кворум | Допустимое количество отказов |
|---------------------|--------|-------------------------------|
| 1                   | 1      | 0                             |
| 2                   | 2      | 0                             |
| 3                   | 2      | 1                             |
| 4                   | 2      | 1                             |
| 5                   | 3      | 1                             |
| 6                   | 4      | 2                             |
| 7                   | 4      | 3                             |

### Persistence

![Redis Persistence](images/Redis%20Persistence.png)

#### Постоянное хранение данных не используется

Если нужно — постоянное хранение данных можно отключить. Это — конфигурация, при использовании которой Redis работает
быстрее всего, но при этом не гарантируется надёжное хранение данных.

#### RDB-файлы

Постоянное хранение данных в файлах RDB подразумевает создание снепшотов, содержащих данные, актуальные на определённые
моменты времени. Snapshot создаются с заданными временными интервалами.

Главный минус этого механизма заключается в том, что данные, поступившие в хранилище между моментами создания снепшотов,
будут, при сбое Redis, утеряны. Кроме того, этот механизм хранения данных полагается на создание форка главного
процесса. При работе с большими наборами данных это может привести к кратковременным задержкам в обработке запросов. Но,
при этом, RDB-файлы загружаются в память гораздо быстрее, чем AOF.

#### Append-only File

Механизм постоянного хранения данных, основанный на AOF, осуществляет журналирование каждой операции записи, запрос на
выполнение которой получает сервер. Эти операции будут воспроизведены при запуске сервера, что приведёт к воссозданию
исходного набора данных.

Такой подход к постоянному хранению данных гораздо надёжнее RDB. Ведь речь идёт не о снимках состояния хранилища, а о
файлах, рассчитанных только на присоединение к ним данных. Когда происходят операции, их буферизуют в журнале, но они не
оказываются сразу после этого размещёнными в постоянном хранилище. В журнале содержатся реальные команды, которые, если
нужно восстановить данные, запускают в том порядке, в котором они выполнялись.

Затем, когда это возможно, журнал сбрасывают на диск с помощью fsync (то, когда именно запускается этот процесс,
поддаётся настройке). После этого данные оказываются в постоянном хранилище. Минус этого подхода в том, что такой формат
хранения данных не является компактным, он требует больше места на диске, чем RDB-файлы.

Вызов `fsync()` сбрасывает все модифицированные данные из памяти (то есть — модифицированные страницы файлового буфера),
имеющие отношение к файлу, представленному файловым дескриптором fd, на жесткий диск. В результате вся изменённая
информация может быть восстановлена даже после серьёзного сбоя или перезагрузки системы.

По разным причинам изменения, которые вносят в открытый файл, сначала попадают в кеш, а вызов `fsync()` гарантирует то,
что они будут физически сохранены на диск, то есть — позже их можно будет с диска прочитать.

## Пример

```shell
$ redis-cli -h localhost -p 26379 --askpass
> SENTINEL get-master-addr-by-name mymaster

$ redis-cli -h localhost -p 6379 --askpass
> EVAL "local order = redis.call('HKEYS', KEYS[1]); return redis.call('SADD', KEYS[2], unpack(order));" 2 books words
> SORT words LIMIT 0 50 ALPHA DESC
> SORT words BY books->* DESC LIMIT 0 50
> HGET books address
```

## Ссылки

1. [Разбираемся с Redis](https://habr.com/ru/company/wunderfund/blog/685894/)
