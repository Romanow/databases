# Redis

GUI: [Medis](https://github.com/luin/medis)

| Role     | Address             |
|----------|---------------------|
| Master   | 6379                |
| Slave    | 6380, 6381          |
| Sentinel | 26379, 26380, 26381 |

## Внутреннее устройство

### Типы данных

* [Strings](https://redis.io/docs/data-types/strings/)
* [Lists](https://redis.io/docs/data-types/lists/)
* [Sets](https://redis.io/docs/data-types/sets/)
* [Streams](https://redis.io/docs/data-types/streams/)

### Репликация

Каждый ведущий узел Redis имеет идентификатор (Replication ID) и смещение репликации. Смещение увеличивается при
выполнении любого действия, которое происходит в ведущем узле Redis.

Когда подчинённый узел Redis отстаёт лишь на несколько шагов смещения от ведущего узла, он получает оставшиеся
необработанными команды от ведущего узла, эти команды применяются к данным, так происходит до момента синхронизации
узлов. Если два экземпляра не могут договориться об ID репликации, или ведущий узел не имеет сведений о смещении,
подчинённый узел запрашивает полную синхронизацию данных. Сюда входит создание ведущим узлом нового snapshot RDB и
отправка его подчинённому узлу. В процессе передачи этих данных ведущий узел буферизует промежуточные обновления данных,
произошедшие между моментом создания snapshot и текущим моментом. Эти обновления будут отправлены подчинённому узлу
после того, как он синхронизируется со snapshot. После завершения этого процесса репликация может продолжаться в обычном
режиме.

### Sentinel

Redis Sentinel — это сервис, обеспечивающий создание распределённых систем. И, как и в случае со всеми распределёнными
системами, у Sentinel имеются и сильные, и слабые стороны. В основе Sentinel лежит кластер Sentinel-процессов,
работающих совместно. Они координируют состояние системы, реализуя конфигурацию высокой доступности Redis. Sentinel —
это сервис, защищающий хранилище Redis от сбоев. Поэтому логично то, чтобы этот сервис не имел бы единой точки отказа.

Сервис Sentinel решает несколько задач. Во-первых — он обеспечивает работоспособность и доступность текущих ведущих и
подчинённых узлов. Благодаря этому текущий Sentinel-процесс (вместе с другими подобными процессами) может отреагировать
на ситуацию, когда теряется связь с ведущими и/или подчинёнными узлами. Во-вторых — он играет определённую роль в деле
обнаружения сервисов. Похожим образом в других системах работают Zookeeper и Consul. То есть — когда новый клиент
пытается что-то записать в хранилище Redis, Sentinel сообщит клиенту о том, какой экземпляр Redis в этот момент является
ведущим.

Получается, что узлы Sentinel постоянно мониторят доступность экземпляров Redis и отправляют сведения о них клиентам,
что позволяет клиентам предпринимать определённые действия в тех случаях, когда хранилище даёт сбой.

Использование Redis Sentinel для решения вышеописанных задач позволяет обнаруживать сбои Redis. Процедура обнаружения
сбоя включает в себя получение согласия нескольких узлов Sentinel с тем, что текущий ведущий экземпляр Redis недоступен.
Процесс получения такого согласия называют кворумом (quorum). Это позволяет повысить надёжность системы, защититься от
ситуаций, когда один из процессов ведёт себя неправильно и не может подключиться к ведущему узлу Redis.

| Количество серверов | Кворум | Допустимое количество отказов |
|---------------------|--------|-------------------------------|
| 1                   | 1      | 0                             |
| 2                   | 2      | 0                             |
| 3                   | 2      | 1                             |
| 4                   | 2      | 1                             |
| 5                   | 3      | 1                             |
| 6                   | 4      | 2                             |
| 7                   | 4      | 3                             |

### Persistence

![Redis Persistence](images/Redis%20Persistence.png)

##### Постоянное хранение данных не используется

Если нужно — постоянное хранение данных можно отключить. Это — конфигурация, при использовании которой Redis работает
быстрее всего, но при этом не гарантируется надёжное хранение данных.

##### RDB-файлы

Постоянное хранение данных в файлах RDB подразумевает создание снепшотов, содержащих данные, актуальные на определённые
моменты времени. Snapshot создаются с заданными временными интервалами.

Главный минус этого механизма заключается в том, что данные, поступившие в хранилище между моментами создания снепшотов,
будут, при сбое Redis, утеряны. Кроме того, этот механизм хранения данных полагается на создание форка главного
процесса. При работе с большими наборами данных это может привести к кратковременным задержкам в обработке запросов. Но,
при этом, RDB-файлы загружаются в память гораздо быстрее, чем AOF.

##### Append-only File

Механизм постоянного хранения данных, основанный на AOF, осуществляет журналирование каждой операции записи, запрос на
выполнение которой получает сервер. Эти операции будут воспроизведены при запуске сервера, что приведёт к воссозданию
исходного набора данных.

Такой подход к постоянному хранению данных гораздо надёжнее RDB. Ведь речь идёт не о снимках состояния хранилища, а о
файлах, рассчитанных только на присоединение к ним данных. Когда происходят операции, их буферизуют в журнале, но они не
оказываются сразу после этого размещёнными в постоянном хранилище. В журнале содержатся реальные команды, которые, если
нужно восстановить данные, запускают в том порядке, в котором они выполнялись.

Затем, когда это возможно, журнал сбрасывают на диск с помощью fsync (то, когда именно запускается этот процесс,
поддаётся настройке). После этого данные оказываются в постоянном хранилище. Минус этого подхода в том, что такой формат
хранения данных не является компактным, он требует больше места на диске, чем RDB-файлы.

Вызов `fsync()` сбрасывает все модифицированные данные из памяти (то есть — модифицированные страницы файлового буфера),
имеющие отношение к файлу, представленному файловым дескриптором fd, на жесткий диск. В результате вся изменённая
информация может быть восстановлена даже после серьёзного сбоя или перезагрузки системы.

По разным причинам изменения, которые вносят в открытый файл, сначала попадают в кеш, а вызов `fsync()` гарантирует то,
что они будут физически сохранены на диск, то есть — позже их можно будет с диска прочитать.

### Запуск кластера

Docker: [docker-compose.yml](docker/docker-compose.yml)

```shell
$ docker-compose up -d
```

### Особенности запуска

Для того чтобы Redis поднять в Sentinel внутри Docker нужно чтобы в `sentinel.conf` было прописано:

```
# Normally Sentinel uses only IP addresses and requires SENTINEL MONITOR
# to specify an IP address. Also, it requires the Redis replica-announce-ip
# keyword to specify only IP addresses.
#
# You may enable hostnames support by enabling resolve-hostnames. Note
# that you must make sure your DNS is configured properly and that DNS
# resolution does not introduce very long delays.
#
sentinel resolve-hostnames yes

# When resolve-hostnames is enabled, Sentinel still uses IP addresses
# when exposing instances to users, configuration files, etc. If you want
# to retain the hostnames when announced, enable announce-hostnames below.
#
sentinel announce-hostnames yes
```

При запуске будет строка:

```log
slave slave 192.168.224.3:6379 192.168.224.3 6379 @ mymaster redis-master 6379
```

И на host машине прописать в `/etc/hosts`

```shell
$ sudo tee -a /etc/hosts > /dev/null <<EOT
127.0.0.1    redis-master
127.0.0.1    redis-slave-1
127.0.0.1    redis-slave-2
EOT
```

Без этого Sentinel отдает внутренний ip адрес master ноды и при старте приложения возникает ошибка:

```log
org.springframework.data.redis.RedisConnectionFailureException: Unable to connect to Redis; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.80.2:6379
    at org.springframework.data.redis.connection.lettuce
```

Все redis-sentinel описываются руками, потому что `docker compose up -d --scale redis-sentinel=3` приводит к ошибке:

```
Error response from daemon: Ports are not available: exposing port TCP 0.0.0.0:26379 -> 0.0.0.0:0: listen tcp 0.0.0.0:26379: bind: address already in use
```

### Пример

```shell
$ redis-cli -h localhost -p 6379 --askpass

> EVAL "local order = redis.call('HKEYS', KEYS[1]); return redis.call('SADD', KEYS[2], unpack(order));" 2 books words

> SORT words LIMIT 0 50 ALPHA DESC

> SORT words BY books->* DESC LIMIT 0 50

> HGET books address
```

### Статус master

```shell
$ redis-cli -h localhost -p 26379 --askpass

> SENTINEL get-master-addr-by-name mymaster
```

## Ссылки

1. [High availability with Redis Sentinel](https://redis.io/docs/manual/sentinel/)
2. [Sentinel client spec](https://redis.io/docs/reference/sentinel-clients/)
3. [Разбираемся с Redis](https://habr.com/ru/company/wunderfund/blog/685894/)

#### Образы Docker

1. [Bitnami Redis](https://hub.docker.com/r/bitnami/redis)
2. [Bitnami Redis Sentinel](https://hub.docker.com/r/bitnami/redis-sentinel)
